#!/usr/bin/env python3
"""
Reusable SMTP email sender for content-tools digests.
"""
from __future__ import annotations

import os
import smtplib
import sys
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from dotenv import load_dotenv

load_dotenv()


def send_digest(
    subject: str,
    items: list[dict],
    to_email: str | None = None,
    smtp_config: dict | None = None,
) -> bool:
    """
    Send an HTML digest email.

    items: list of {"title": str, "content": str, "url": str | None}
    smtp_config: optional override dict with keys smtp_server, smtp_port, smtp_user,
                 smtp_password, from_email. Falls back to env vars.
    """
    cfg = smtp_config or {}
    smtp_server = cfg.get("smtp_server") or os.environ.get("SMTP_SERVER", "smtp.gmail.com")
    smtp_port = int(cfg.get("smtp_port") or os.environ.get("SMTP_PORT", "587"))
    smtp_user = cfg.get("smtp_user") or os.environ.get("SMTP_USER")
    smtp_password = cfg.get("smtp_password") or os.environ.get("SMTP_PASSWORD")
    from_email = cfg.get("from_email") or os.environ.get("FROM_EMAIL") or smtp_user
    recipient = to_email or os.environ.get("EMAIL_TO")

    if not smtp_user or not smtp_password:
        print("Error: SMTP_USER and SMTP_PASSWORD required.", file=sys.stderr)
        return False
    if not recipient:
        print("Error: EMAIL_TO not set.", file=sys.stderr)
        return False
    if not items:
        print("No items to send.", file=sys.stderr)
        return False

    html_content = _format_html(subject, items)
    plain_content = _format_plain(items)

    msg = MIMEMultipart("alternative")
    msg["Subject"] = subject
    msg["From"] = from_email
    msg["To"] = recipient
    msg.attach(MIMEText(plain_content, "plain"))
    msg.attach(MIMEText(html_content, "html"))

    try:
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(smtp_user, smtp_password)
            server.send_message(msg)
        print(f"Email sent to {recipient}: {subject}")
        return True
    except Exception as e:
        print(f"Error sending email: {e}", file=sys.stderr)
        return False


def _format_html(title: str, items: list[dict]) -> str:
    date_str = datetime.now().strftime("%B %d, %Y")
    count = len(items)

    cards = ""
    for item in items:
        link_html = (
            f'<a href="{item["url"]}" class="item-link">View source</a>'
            if item.get("url")
            else ""
        )
        content_html = _markdown_to_html(item.get("content", ""))
        cards += f"""
        <div class="item">
            <div class="item-title">{item.get("title", "Untitled")}</div>
            {link_html}
            <div class="item-content">{content_html}</div>
        </div>
        """

    return f"""
    <html>
    <head>
        <style>
            body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}
            .wrapper {{ max-width: 700px; margin: 0 auto; background: white; border-radius: 8px; overflow: hidden; }}
            .header {{ background: #4CAF50; color: white; padding: 24px; }}
            .header h1 {{ margin: 0 0 4px 0; font-size: 22px; }}
            .header p {{ margin: 0; opacity: 0.85; font-size: 14px; }}
            .body {{ padding: 20px; }}
            .count {{ color: #555; margin-bottom: 16px; }}
            .item {{ background: #f9f9f9; padding: 16px; margin-bottom: 16px; border-radius: 8px; border-left: 4px solid #4CAF50; }}
            .item-title {{ font-size: 17px; font-weight: bold; color: #222; margin-bottom: 8px; }}
            .item-link {{ display: inline-block; background: #2196F3; color: white; padding: 6px 14px; text-decoration: none; border-radius: 4px; font-size: 13px; margin-bottom: 12px; }}
            .item-content {{ color: #444; line-height: 1.65; font-size: 14px; }}
            .item-content h2, .item-content h3 {{ font-size: 15px; color: #2196F3; margin: 12px 0 6px 0; }}
            .item-content ul {{ margin: 4px 0; padding-left: 20px; }}
            .footer {{ color: #aaa; font-size: 12px; padding: 16px 20px; border-top: 1px solid #eee; }}
        </style>
    </head>
    <body>
        <div class="wrapper">
            <div class="header">
                <h1>{title}</h1>
                <p>{date_str}</p>
            </div>
            <div class="body">
                <p class="count"><strong>{count}</strong> item(s) in this digest.</p>
                {cards}
            </div>
            <div class="footer">Generated by content-tools</div>
        </div>
    </body>
    </html>
    """


def _format_plain(items: list[dict]) -> str:
    lines = []
    for item in items:
        lines.append(f"=== {item.get('title', 'Untitled')} ===")
        if item.get("url"):
            lines.append(item["url"])
        lines.append(item.get("content", ""))
        lines.append("")
    return "\n".join(lines)


def _markdown_to_html(text: str) -> str:
    import re
    # Convert ## headings
    text = re.sub(r"^## (.+)$", r"<h3>\1</h3>", text, flags=re.MULTILINE)
    text = re.sub(r"^# (.+)$", r"<h2>\1</h2>", text, flags=re.MULTILINE)
    # Convert bullet points
    text = re.sub(r"^- (.+)$", r"<li>\1</li>", text, flags=re.MULTILINE)
    text = re.sub(r"(<li>.*</li>)", r"<ul>\1</ul>", text, flags=re.DOTALL)
    # Wrap paragraphs (blank-line-separated non-tag blocks)
    paragraphs = re.split(r"\n{2,}", text)
    result = []
    for p in paragraphs:
        p = p.strip()
        if p and not p.startswith("<"):
            p = f"<p>{p}</p>"
        result.append(p)
    return "\n".join(result)
